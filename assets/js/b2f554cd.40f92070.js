"use strict";(self.webpackChunkcyclops_ui_docs=self.webpackChunkcyclops_ui_docs||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/12/08/five-kubernetes-tools","metadata":{"permalink":"/blog/2023/12/08/five-kubernetes-tools","source":"@site/blog/2023-12-08-five-kubernetes-tools/index.md","title":"Five Kubernetes Development Tools for Efficient Cluster Management","description":"kubernetes tools","date":"2023-12-08T00:00:00.000Z","formattedDate":"December 8, 2023","tags":[],"readingTime":7.065,"hasTruncateMarker":false,"authors":[{"name":"Juraj Karad\u017ea","title":"Cyclops CEO","url":"https://github.com/KaradzaJuraj","imageURL":"https://github.com/KaradzaJuraj.png","key":"jurajk"}],"frontMatter":{"title":"Five Kubernetes Development Tools for Efficient Cluster Management","authors":["jurajk"]},"unlisted":false,"nextItem":{"title":"How Cyclops utilizes JSON schema to deliver dynamical UI","permalink":"/blog/2023/11/13/JSON-schemas"}},"content":"![kubernetes tools](../../static/img/2023-12-08-five-kubernetes-tools/kubernetes_tools.png)\\n\\nKubernetes has become the go-to platform for managing containerized applications, offering scalability, flexibility, and robustness. However, the complexity of Kubernetes can be daunting, requiring developers and DevOps teams to navigate through intricate configuration files and command-line interactions. \\n\\nSeveral powerful development tools have emerged to simplify the management of Kubernetes clusters and streamline the deployment process. In this article, we will explore five Kubernetes development tools: \\n\\n1. [**1. Pometheus**](https://prometheus.io/)\\n2. [**2. Cyclops**](https://cyclops-ui.com/)\\n3. [**3. Keda**](https://keda.sh/)\\n4. [**4. Karpenter**](https://karpenter.sh/)\\n5. [**5. Velero**](https://velero.io/)\\n\\nThese tools offer intuitive user interfaces, automated scaling capabilities, disaster recovery solutions, and improved efficiency in managing Kubernetes clusters.\\n\\n### Show us your support \ud83d\ude4f\ud83c\udffb\\n\\nBefore we start, we would love it if you starred our repository and helped us get our \\ntool in front of other developers. Our GitHub repo is here: https://github.com/cyclops-ui/cyclops \u2b50\\n\\n## 1. Prometheus: Monitoring and Alerting for Kubernetes\\n![Prometheus logo](../../static/img/2023-12-08-five-kubernetes-tools/prometheus_logo.png)\\n\\n**Prometheus** is an open-source monitoring and alerting toolkit designed specifically for microservices and containers. It offers flexible querying, real-time notifications, and visibility into containerized workloads, APIs, and distributed services. \\n\\nOne of the features of Prometheus is its ability to assist with cloud-native security by detecting irregular traffic or activity that could potentially escalate into an attack.\\n\\nIt uses a pull-based system, sending HTTP requests called \\"scrapes\\", to collect metrics from applications and services. These metrics are stored in memory and on local disk, allowing for easy retrieval and analysis.\\n\\nPrometheus can access data directly from client libraries or through exporters, which are software located adjacent to the application. Exporters accept HTTP requests from Prometheus, ensure the data format compatibility, and serve the requested data to the Prometheus server.\\n\\nPrometheus provides four main types of metrics: Counter, Gauge, Histogram, and Summary. These metrics offer flexibility in measuring various aspects of applications and services, such as event start counts, memory usage, data aggregation, and quantile ranges.\\n\\nTo discover targets for monitoring, Prometheus utilizes service discovery in Kubernetes clusters. It can access machine-level metrics separately from application information, allowing for comprehensive monitoring.\\n\\nOnce the data collection is complete, Prometheus provides a query language called PromQL, which enables users to access and export monitoring data to graphical interfaces like Grafana or send alerts using Alertmanager.\\n\\n## 2. Cyclops: Deploying applications with just a couple of clicks\\n\\n![Cyclops logo](../../static/img/2023-12-08-five-kubernetes-tools/cyclops_logo.png)\\n\\n**Cyclops** is a tool that simplifies the management of applications running in Kubernetes clusters. It abstracts complex configuration files into form-based UIs, eliminating the need for manual configuration and command-line interactions. This makes the deployment process more accessible to individuals with varying levels of technical expertise.\\n\\nWith Cyclops, you\'re not boxed into a one-size-fits-all approach. You can customize modules to suit your unique needs, giving you the freedom to create templates with input validation for seamless collaboration with your team. \\n\\nThis not only speeds up your work but also empowers each team member to work independently, promoting a smoother and more efficient workflow.\\n\\nIn Cyclops, every module lays out a detailed list of resources it uses\u2014deployments, services, pods, and others, all in plain view. You can easily track their status, helping you quickly spot and fix any hiccups in your application. It\'s like having a clear roadmap to navigate and troubleshoot any issues that pop up.\\n\\nWithin the architecture of Cyclops, a central component is the [Helm](https://helm.sh/) engine, which allows the dynamic generation of configurations. This engine serves as a key mechanism for efficiently managing settings and parameters in the Cyclops framework.\\n\\nAs Kubernetes-based systems commonly employ Helm as their package manager, seamlessly integrating Cyclops is a straightforward process.\\n\\nCyclops promotes consistency and standardization in deployment practices. By providing predefined templates or configuration presets, Cyclops ensures that deployments adhere to established best practices and guidelines. This consistency not only improves the reliability and stability of deployments but also facilitates collaboration.\\n\\n## 3. Keda: Event-Driven Autoscaling for Kubernetes Workloads\\n\\n![Keda logo](../../static/img/2023-12-08-five-kubernetes-tools/keda_logo.png)\\n\\nKubernetes Horizontal Pod Autoscaling (HPA) and Vertical Pod Autoscaling (VPA) are widely used for autoscaling Kubernetes clusters based on CPU and memory usage. \\n\\nHowever, they have limitations, such as the inability to scale pods to zero or scale based on metrics other than resource utilization. This is where **Keda** (Kubernetes Event-Driven Autoscaling) comes into play.\\n\\nKeda is an open-source container autoscaler that extends the capabilities of native Kubernetes autoscaling solutions by scaling pods based on external events or triggers.\\n\\nMonitoring event sources like AWS SQS, Kafka, and RabbitMQ, Keda efficiently triggers or halts deployments based on predefined rules. This adaptable solution also allows for custom metrics, facilitating effective autoscaling tailored for message-driven microservices, ensuring optimal performance and resource utilization.\\n\\nThe components of Keda include event sources, scalers, metrics adapters, and controllers. Event sources provide the external events that trigger scaling, while scalers monitor these events and fetch metrics. Metrics adapters translate the metrics for the controller, which then scales the deployments accordingly.\\n\\nBy leveraging Keda, DevOps teams can free up resources and reduce cloud costs by scaling down when there are no events to process. Keda also offers interoperability with various DevOps toolchains, supporting both built-in and external scalers. \\n\\nWith Keda, autoscaling becomes more flexible and efficient, empowering teams to optimize resource utilization and adapt to changing workload requirements.\\n\\n## 4. Karpenter: Automated Node Provisioning for Kubernetes\\n\\n![Karpenter logo](../../static/img/2023-12-08-five-kubernetes-tools/karpenter_logo.png)\\n\\nKubernetes clusters often face the challenge of scheduling pods on available nodes. **Karpenter** is an open-source cluster auto scaler that automatically provisions new nodes in response to un-schedulable pods. It evaluates the aggregate resource requirements of pending pods and selects the optimal instance type to accommodate them. \\n\\nKarpenter also supports a consolidation feature, actively moving pods and replacing nodes with cheaper versions to reduce cluster costs.\\n\\nA standout feature is the introduction of \\"Node Pools,\\" allowing users to categorize nodes based on various criteria. This customization ensures a tailored approach to resource allocation, with Karpenter dynamically provisioning nodes into the most fitting pools.\\n\\nAt its core, Karpenter is designed to automate the scaling of Kubernetes clusters seamlessly. Leveraging Custom Resource Definitions (CRDs) within Kubernetes, Karpenter integrates seamlessly with existing tools and APIs, providing a familiar experience for users. \\n\\nThe flexibility of Karpenter extends beyond the confines of AWS, making it a versatile solution for both cloud and on-premises environments.\\n\\nKarpenter\'s adaptability shines through its support for user-defined strategies and policies through Kubernetes resources. This flexibility enables organizations to align Karpenter with their unique application and workload requirements, enabling better automated and optimized Kubernetes scalability.\\n\\n## 5. Velero: Disaster Recovery and Backup for Kubernetes\\n![Velero logo](../../static/img/2023-12-08-five-kubernetes-tools/velero_logo.png)\\n\\n**Velero** is a powerful tool that provides disaster recovery and backup solutions for Kubernetes clusters. It enables users to easily backup, restore, and migrate applications and their persistent volumes.\\n\\nVelero takes snapshots of cluster resources and data, storing them in object storage providers like AWS S3, Google Cloud Storage, or Azure Blob Storage.\\n\\nWith Velero, users can create backup schedules, ensuring regular snapshots of critical cluster resources. This allows for efficient disaster recovery in case of data loss or cluster failures. Velero also supports cluster migration, simplifying the process of moving applications and data between Kubernetes clusters.\\n\\nThe tool offers resource filtering capabilities, allowing users to selectively backup and restore specific resources.\\n\\nThis flexibility ensures that only relevant data is included in the backup, saving storage space and reducing backup and restore times. Velero integrates with CSI (Container Storage Interface), providing support for backing up volumes and restoring them to their original state.\\n\\nIn addition to disaster recovery and backup, Velero provides features like running in any namespace, extending functionality with hooks, and supporting custom plugins for enhanced customization. It offers troubleshooting guides for diagnosing and resolving common issues, ensuring a smooth experience in managing Kubernetes clusters.\\n\\n## Conclusion\\n\\nThese five Kubernetes development tools - Prometheus, Cyclops, Keda, Karpenter, and Velero - play pivotal roles in simplifying the complexities of Kubernetes cluster management.\\n\\nFrom monitoring and alerting with Prometheus to event-driven autoscaling using Keda, and automated node provisioning through Karpenter, each tool addresses specific challenges, contributing to more efficient and resilient Kubernetes environments.\\n\\nCyclops stands out for its user-friendly approach, abstracting complex configurations into intuitive UIs, while Velero provides crucial disaster recovery and backup solutions for safeguarding critical data and applications.\\n\\nAs Kubernetes continues to be a cornerstone in modern application deployment, these tools empower developers and DevOps teams to navigate the intricacies of containerized environments with greater ease.\\n\\nBy integrating these tools into your Kubernetes workflows, you can enhance scalability, streamline deployment processes, and ensure the robustness of your applications in today\'s dynamic and demanding computing landscape."},{"id":"/2023/11/13/JSON-schemas","metadata":{"permalink":"/blog/2023/11/13/JSON-schemas","source":"@site/blog/2023-11-13-JSON-schemas/index.md","title":"How Cyclops utilizes JSON schema to deliver dynamical UI","description":"Cyclops turns complicated YAML manifests into simple and structured UIs where developers can click away their Kubernetes application configuration.","date":"2023-11-13T00:00:00.000Z","formattedDate":"November 13, 2023","tags":[],"readingTime":3.725,"hasTruncateMarker":false,"authors":[{"name":"Petar Cvitanovi\u0107","title":"Cyclops CTO","url":"https://github.com/petar-cvit","imageURL":"https://github.com/petar-cvit.png","key":"petarc"}],"frontMatter":{"title":"How Cyclops utilizes JSON schema to deliver dynamical UI","authors":["petarc"]},"unlisted":false,"prevItem":{"title":"Five Kubernetes Development Tools for Efficient Cluster Management","permalink":"/blog/2023/12/08/five-kubernetes-tools"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"Cyclops turns complicated YAML manifests into simple and structured UIs where developers can click away their Kubernetes application configuration.\\n\u201dGreat! But how does it know how to render this UI? Should I implement a UI form each time I need a new set of fields to configure? I don\u2019t know React! I don\u2019t know frontend!\u201c\\n\\nThis blog post should cure your anxiety about implementing a UI for each type of application and explain how Cyclops knows what to render so you can deploy to your K8s cluster carefree.\\n\\nTo better understand how Cyclops renders the UI, we will scratch the surface of Helm, which Cyclops uses as its templating engine.\\n\\n## A bit about Helm\\n\\nHelm is a Kubernetes package manager that helps deploy and manage Kubernetes resources by packing them into charts. It also has a templating engine that allows developers to configure their apps depending on the specific values injected into the helm template.\\n\\nThe usual Helm chart structure is as follows:\\n\\n```bash\\n\u251c\u2500\u2500 Chart.yaml\\n\u251c\u2500\u2500 templates\\n\u2502   \u251c\u2500\u2500 deployment.yaml\\n\u2502   \u2514\u2500\u2500 service.yaml\\n\u251c\u2500\u2500 values.schema.json\\n\u2514\u2500\u2500 values.yaml\\n```\\n\\n> A few other Helm chart parts are left out on purpose since they are not tangible to the rest of the blog. You can read more about each of those in [Helm\u2019s official documentation](https://helm.sh/docs/topics/charts/)\\n\\n- `Chart.yaml` - A YAML file containing information about the chart (like name, version\u2026)\\n- `templates` - A directory of templates that, when combined with values, will generate valid Kubernetes manifest files\\n- `values.yaml` - The default configuration values for this chart\\n- `values.schema.json` - A JSON Schema for imposing a structure on the `values.yaml` file\\n\\nWhen using Helm, you can change your `values.yaml` however you see fit for your application. The problem is that you can change them __however__ you like, which allows you to misconfigure some parts of your application because you misspelled a field or messed up indentation in the `values.yaml`.\\n\\nHere is where [JSON schema](https://json-schema.org) from the `values.schema.json` comes in. It will define which fields you should set and even to which values (e.g., you can specify that a field called replicas can\u2019t be set to lower than 0). Helm won\u2019t let you render a Kubernetes manifest with values that don\u2019t comply with the schema. There is an example of such schema later in the blog, but you can also check it out on [Helms official docs](https://helm.sh/docs/topics/charts/#schema-files)\\n\\n## Helm values schema and Cyclops UI\\n\\nNow that the schema\'s purpose in a Helm chart is explained let\u2019s get into how Cyclops uses it.\\n\\nSince the primary purpose of the values schema is to describe what the Helm chart needs to render all the Kubernetes resources, we naturally decided to use it for rendering the UI. On the first iterations of Cyclops, we implemented a solution where users can define those fields in the UI, but why reinvent the wheel when Helm already provided a way to specify this?\\n\\nCyclops controller reads the Helm chart and values schema. Then, it recursively traverses through all the fields in the schema and renders the field based on the field specification. It knows how to render a field based on the field type (`string`, `boolean`, `object`, `array`...), description of the field, field rules (e.g., minimum or maximum value), and many more.\\n\\n![Untitled](../../static/img/2023-11-13-JSON-schemas/JSON-to-UI.png)\\n\\nNow that the UI is rendered, a user of Cyclops can click through the form and fill in those fields. Thanks to the schema, values entered by a developer will now always conform to the schema since the UI won\u2019t let you specify any fields (e.g., allow you typos in field names) or set the number of replicas to `three` instead of `3`. This is an exaggerated example, but you can probably see the point. The UI will take care of validating your input, and you will have clear guidelines on how to configure your service.\\n\\nOnce values are entered and saved in the UI, they are passed to the Helm templating engine and the templates from the `/templates` folder. This results in all Kubernetes resources being configured for the needs of each team/developer without getting into specific implementation details of each resource.\\n\\n![Untitled](../../static/img/2023-11-13-JSON-schemas/UI-to-K8s.png)\\n\\n## Final thoughts\\n\\nHope this blog post helped you understand how the rendering part of Cyclops works and demystified the whole project. We briefly touched on [Helm](https://helm.sh/docs/) and [JSON schema](https://json-schema.org/), but both are larger pieces of software that we can\'t describe in such a short blog post, so we encourage you to check their documentation."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2023-10-29-welcome/index.md","title":"Welcome","description":"Hi all!","date":"2023-10-29T00:00:00.000Z","formattedDate":"October 29, 2023","tags":[],"readingTime":0.525,"hasTruncateMarker":false,"authors":[{"name":"Petar Cvitanovi\u0107","title":"Cyclops CTO","url":"https://github.com/petar-cvit","imageURL":"https://github.com/petar-cvit.png","key":"petarc"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["petarc"]},"unlisted":false,"prevItem":{"title":"How Cyclops utilizes JSON schema to deliver dynamical UI","permalink":"/blog/2023/11/13/JSON-schemas"}},"content":"Hi all!\\n\\nWe are launching a blog post series on topics relevant to people following our startup journey. From technical topics \\nlike building high availability apps in Kubernetes to nontechnical ones, like our experience in some of the accelerators\\nwe have been through.\\n\\nOverall, we hope you will enjoy the content, and of course, you are more than encouraged to propose some topics you \\nwould like to see here on our Discord.\\n\\nAlso, if you are interested in contributing to our project, you can find open issues on our GitHub repository, and while\\nyou are there, give it a star :star:\\n\\n**Blog posts coming soon...**"}]}')}}]);