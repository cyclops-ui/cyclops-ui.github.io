"use strict";(self.webpackChunkcyclops_ui_docs=self.webpackChunkcyclops_ui_docs||[]).push([[5004],{44449:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>h});var o=n(74848),s=n(28453);const r={title:"Complexity by Simplicity - A Deep Dive Into Kubernetes Components",authors:["jurajk"]},i="Intro",a={permalink:"/blog/2023/12/18/k8s-cluster-components",source:"@site/blog/2023-12-18-k8s-cluster-components/index.md",title:"Complexity by Simplicity - A Deep Dive Into Kubernetes Components",description:"Image of a Kubernetes cluster based on an image found on https://kubernetes.io/docs/concepts/overview/components/",date:"2023-12-18T00:00:00.000Z",formattedDate:"December 18, 2023",tags:[],readingTime:8.34,hasTruncateMarker:!1,authors:[{name:"Juraj Karad\u017ea",title:"Cyclops CEO",url:"https://github.com/KaradzaJuraj",imageURL:"https://github.com/KaradzaJuraj.png",key:"jurajk"}],frontMatter:{title:"Complexity by Simplicity - A Deep Dive Into Kubernetes Components",authors:["jurajk"]},unlisted:!1,prevItem:{title:"Kubernetes Made Simple - Introducing Cyclops",permalink:"/blog/2024/1/3/cyclops-overview"},nextItem:{title:"Five Kubernetes Development Tools for Efficient Cluster Management",permalink:"/blog/2023/12/08/five-kubernetes-tools"}},l={authorsImageUrls:[void 0]},h=[{value:"<strong>Show us your support \ud83d\ude4f\ud83c\udffb</strong>",id:"show-us-your-support-",level:3},{value:"Control plane",id:"control-plane",level:2},{value:"API",id:"api",level:3},{value:"ETCD",id:"etcd",level:3},{value:"Scheduler",id:"scheduler",level:3},{value:"Controller Manager",id:"controller-manager",level:3},{value:"Worker nodes",id:"worker-nodes",level:2},{value:"Container runtime",id:"container-runtime",level:3},{value:"Kubelet",id:"kubelet",level:3},{value:"Kube proxy",id:"kube-proxy",level:3},{value:"Pods, Replicasets and Deployments",id:"pods-replicasets-and-deployments",level:2},{value:"The Prestige",id:"the-prestige",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Image of a Kubernetes cluster based on an image found on https://kubernetes.io/docs/concepts/overview/components/",src:n(15928).A+"",width:"10475",height:"5618"})}),"\n",(0,o.jsx)(t.p,{children:"A couple of days ago, I held a talk about Kubernetes and its components at the college I used to go to. My mom said she liked the talk, so I turned it into a blog post."}),"\n",(0,o.jsx)(t.p,{children:"Many software engineers tend to look away from anything related to Kubernetes, even though they might use it daily. At first glance, it seems complex and like a whole new world to dive into. And yeah, it is, but in this blog post, I will go over all of the main components of a Kubernetes cluster and explain what they do in an example."}),"\n",(0,o.jsx)(t.p,{children:"By the end of the blog post, you won't be a Kubernetes expert, but you will probably get a good idea of what to look for and how to structure the chaos that Kubernetes seems to be at first."}),"\n",(0,o.jsx)(t.h3,{id:"show-us-your-support-",children:(0,o.jsx)(t.strong,{children:"Show us your support \ud83d\ude4f\ud83c\udffb"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Github Stars",src:n(64227).A+"",width:"480",height:"360"})}),"\n",(0,o.jsxs)(t.p,{children:["Before we start, we would love it if you starred our repository and helped us get our tool in front of other developers. Our GitHub repo is here:\xa0",(0,o.jsx)(t.a,{href:"https://github.com/cyclops-ui/cyclops",children:"https://github.com/cyclops-ui/cyclops"}),"\xa0\u2b50"]}),"\n",(0,o.jsx)(t.h1,{id:"components",children:"Components"}),"\n",(0,o.jsxs)(t.p,{children:["First of all, we can divide a Kubernetes cluster into two parts: ",(0,o.jsx)(t.strong,{children:"control plane"})," and ",(0,o.jsx)(t.strong,{children:"worker nodes"}),". The control plane takes care of the whole operation and controls the state of our cluster. We\u2019ll get into what that means shortly. On the other side, our worker nodes are essentially just computers listening to what the control plane tells them to do. They are the computing power of our cluster. Any application we run in the cluster will run on those nodes."]}),"\n",(0,o.jsx)(t.p,{children:"Let\u2019s decompose that further."}),"\n",(0,o.jsx)(t.h2,{id:"control-plane",children:"Control plane"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Control Plane",src:n(82143).A+"",width:"10475",height:"5618"})}),"\n",(0,o.jsx)(t.p,{children:"As we said, the control plane is making sure our cluster is running as expected. It does that by communicating with the cluster user, scheduling workloads, managing cluster state and so on."}),"\n",(0,o.jsx)(t.p,{children:"The control plane is made of four crucial components. Simple by themselves, but together, they create a complex system. These components are:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"1. API"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"2. ETCD"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"3. Scheduler"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"4. Controller Manager"})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Control plane components can be run on any machine in the cluster, but are usually run on a separate set of machines, often called ",(0,o.jsx)(t.strong,{children:"master nodes"}),". Those machines are not used to run any other container or application and are reserved for the Kubernetes control plane."]}),"\n",(0,o.jsx)(t.h3,{id:"api",children:"API"}),"\n",(0,o.jsx)(t.p,{children:"The Kubernetes API acts as the cluster's front-end interface, allowing users to interact with the cluster, define desired states, and perform operations such as creating, updating, and deleting resources."}),"\n",(0,o.jsxs)(t.p,{children:["It is the ",(0,o.jsx)(t.strong,{children:"only point of contact"})," we have with the cluster. Also, no other components are talking directly to each other, but all communication is happening ",(0,o.jsx)(t.strong,{children:"through"})," the API."]}),"\n",(0,o.jsx)(t.h3,{id:"etcd",children:"ETCD"}),"\n",(0,o.jsxs)(t.p,{children:["ETCD is the API\u2019s ",(0,o.jsx)(t.strong,{children:"database"}),"; it's as simple as that. When you tell Kubernetes to create a deployment, it gets stored in the ETCD alongside all the other created resources."]}),"\n",(0,o.jsxs)(t.p,{children:["One characteristic of ETCD is that its key-value storage is organized as a filesystem. Another great feature of ETCD is that users can ",(0,o.jsx)(t.strong,{children:"subscribe"})," to events and get notified about changes. For example, ",(0,o.jsx)(t.em,{children:"let me know when a new pod gets created"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"scheduler",children:"Scheduler"}),"\n",(0,o.jsxs)(t.p,{children:["As the name suggests, the scheduler ",(0,o.jsx)(t.strong,{children:"decides which node a pod will run on"}),". It does that by a set of rules you can read in the ",(0,o.jsx)(t.a,{href:"https://kubernetes.io/docs/home/",children:"Kubernetes documentation"}),". ",(0,o.jsx)(t.em,{children:"This is what I meant when I said you won't be an expert, but you will know what to google :)"})]}),"\n",(0,o.jsxs)(t.p,{children:["The Scheduler ",(0,o.jsx)(t.strong,{children:"subscribes"})," to all newly created pods saved in ETCD, but it can ",(0,o.jsx)(t.strong,{children:"only"})," talk with the API to get this update."]}),"\n",(0,o.jsxs)(t.p,{children:["When it catches that a pod has been created, it calculates which worker node to run it on. Once it's made up its mind, ",(0,o.jsx)(t.strong,{children:"the scheduler doesn't run anything on any machine"}),"; it just tells the API to run the pod on a particular node."]}),"\n",(0,o.jsx)(t.h3,{id:"controller-manager",children:"Controller Manager"}),"\n",(0,o.jsx)(t.p,{children:"The last component from the control plane is the controller manager. We can take it as a thermostat for our cluster. Its job is to shift the current state of the cluster to the desired state."}),"\n",(0,o.jsxs)(t.p,{children:["This means that it will ",(0,o.jsx)(t.strong,{children:"create all the needed resources"})," under the hood to satisfy our needs and get our applications up and running."]}),"\n",(0,o.jsx)(t.p,{children:"It runs multiple controller processes subscribed to changes on the ETCD, compiled into the same binary for easier deployment. Controller managers\u2019 roles and what those controllers do will be defined more closely later in the blog."}),"\n",(0,o.jsx)(t.h2,{id:"worker-nodes",children:"Worker nodes"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Worker nodes",src:n(99944).A+"",width:"10475",height:"5618"})}),"\n",(0,o.jsx)(t.p,{children:"Now that we have concluded what manages the whole cluster, let's dive into where our containers are running and how that is achieved."}),"\n",(0,o.jsx)(t.p,{children:"There are 3 components running on each node in a Kubernetes cluster. Of course, you can have multiple nodes in a cluster, but each needs these three components to host your applications."}),"\n",(0,o.jsx)(t.p,{children:"Those being:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"1. container runtime"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"2. kubelet"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"3. kube proxy"})}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"container-runtime",children:"Container runtime"}),"\n",(0,o.jsx)(t.p,{children:"The component that allows Kubernetes to run containers and manages the lifecycle of a container on a node is the container runtime."}),"\n",(0,o.jsxs)(t.p,{children:["Multiple container runtimes are supported, like ",(0,o.jsx)(t.a,{href:"https://containerd.io/",children:"conatinerd"}),", ",(0,o.jsx)(t.a,{href:"https://cri-o.io/",children:"cri-o"}),", or other ",(0,o.jsx)(t.a,{href:"https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md",children:"CRI compliant runtimes"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"kubelet",children:"Kubelet"}),"\n",(0,o.jsx)(t.p,{children:"Another component subscribed to pod events is Kubelet. Each time a pod is scheduled on a node, the Kubelet running on that node will hear that and start all defined containers. On top of that, Kubelet also performs health checks to ensure everything is running as expected."}),"\n",(0,o.jsx)(t.h3,{id:"kube-proxy",children:"Kube proxy"}),"\n",(0,o.jsx)(t.p,{children:"KubeProxy in Kubernetes manages network connectivity between pods across the cluster, handling tasks like load balancing and network routing. It ensures seamless communication among pods by maintaining network rules and translating service abstractions into actionable network policies."}),"\n",(0,o.jsx)(t.h1,{id:"from-a-deployment-to-a-running-container",children:"From a deployment to a running container"}),"\n",(0,o.jsx)(t.p,{children:"Now that we have listed all of the components and their role in a Kubernetes cluster, let's tell a story on how a Kubernetes Deployment becomes a set of containers running on various machines across the cluster."}),"\n",(0,o.jsx)(t.h2,{id:"pods-replicasets-and-deployments",children:"Pods, Replicasets and Deployments"}),"\n",(0,o.jsx)(t.p,{children:"Just a quick reminder on the relation of these three: Pods, Replicasets, and Deployments."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Deployment components",src:n(82187).A+"",width:"10020",height:"5545"})}),"\n",(0,o.jsxs)(t.p,{children:["The smallest unit we can deploy in a Kubernetes cluster is a ",(0,o.jsx)(t.strong,{children:"pod"}),". With it, we are going to define our containers."]}),"\n",(0,o.jsxs)(t.p,{children:["Most likely, we will need a couple of instances of the same application, and we can define how to replicate our pods with a ",(0,o.jsx)(t.strong,{children:"Replicaset"}),". It will ensure that we have the desired number of pods running by starting and terminating them."]}),"\n",(0,o.jsx)(t.p,{children:"Cool, now we have our application replicated, but we would like to roll out a new version of our application. We have to tear down existing Pods/Replicaset and create new ones. A Deployment will automate this process, allowing us to roll out our feature safely."}),"\n",(0,o.jsx)(t.h2,{id:"the-prestige",children:"The Prestige"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Prestige",src:n(19096).A+"",width:"500",height:"250"})}),"\n",(0,o.jsx)(t.p,{children:"Now that we have all our terminology and touched on all Kubernetes components and their role, let's see what happens when we \u201capply\u201d a Deployment to a Kubernetes cluster."}),"\n",(0,o.jsxs)(t.p,{children:["Let's say that we have created a ",(0,o.jsx)(t.code,{children:"deployment.yaml"})," file defining our application (you can see how to do that ",(0,o.jsx)(t.a,{href:"https://imgur.com/7qKp189",children:"here"}),") and ran ",(0,o.jsx)(t.code,{children:"kubectl apply -f deployment.yaml"}),". ",(0,o.jsx)(t.code,{children:"kubectl"})," will now submit our deployment definition to our cluster's ",(0,o.jsx)(t.strong,{children:"only point of contact"})," - the Kubernetes API."]}),"\n",(0,o.jsxs)(t.p,{children:["Our simple API will store our deployment in the ETCD database. Each time a Deployment object is saved into ETCD, it will let the API know that there was a change on Deployments and that it should let ",(0,o.jsx)(t.strong,{children:"everybody who is subscribed"})," to such an event know about it."]}),"\n",(0,o.jsxs)(t.p,{children:["And there is a component in the control plane that would like to know when a new Deployment spawns, and that's the ",(0,o.jsx)(t.strong,{children:"Controller Manager"}),". When it hears about a new Deployment, it will create a new Replicaset based on the Deployment configuration. To make this Replicaset, it will call the API with a create request."]}),"\n",(0,o.jsxs)(t.p,{children:["Creating a Replicaset is much like creating a Deployment. API will receive a Replicaset to create and store into ETCD. This will make ETCD tell the API that somebody created a Replicaset and pass that information to all subscribed components, which is ",(0,o.jsx)(t.strong,{children:"again"})," the Controller Manager."]}),"\n",(0,o.jsx)(t.p,{children:"When the Controller Manager hears about the new Replicaset, it will create all the Pods defined with the Replicaset by, you guessed it, calling the API, which will store all those Pods into ETCD."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:" As we said, a lot of things happened, so we decided to create a GIF that might help you understand the whole process under the hood.",src:n(38506).A+"",width:"1332",height:"737"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"As we said, a lot of things happened, so we decided to create a GIF that might help you understand the whole process under the hood."})}),"\n",(0,o.jsxs)(t.p,{children:["Here, we include the Scheduler, which is subscribed to the Pod creation event. Each time it hears about a new Pod, it decides on which node it should be run. The Scheduler is not running the Pod but ",(0,o.jsx)(t.strong,{children:"only telling the API"})," which node it chose for it. The API will then save that information."]}),"\n",(0,o.jsxs)(t.p,{children:["Another component listening to Pod events is the Kubelet, a component running on each worker node in the Kubernetes cluster. Each time the API tells the Kubelet that the Scheduler decided to run the Pod on its node, the Kubelet ",(0,o.jsx)(t.strong,{children:"will start all the containers"})," defined by the Pod."]}),"\n",(0,o.jsx)(t.p,{children:"Finally, we turned our configuration into an application running on a machine! It is a lengthy process with many moving parts, but this may be my favorite part."}),"\n",(0,o.jsx)(t.p,{children:"Each component takes just a tiny bit of the responsibility of deploying an application, but they solve a pretty complex problem together."}),"\n",(0,o.jsx)(t.h1,{id:"final-thoughts",children:"Final thoughts"}),"\n",(0,o.jsx)(t.p,{children:"Hope this article helped you get a grasp on Kubernetes components and helped you demystify the most popular orchestrator out there. We encourage you to dig around yourself because we enjoyed learning about this."}),"\n",(0,o.jsx)(t.p,{children:"One book we recommend to learn about Kubernetes is \u201cKubernetes in action\u201d by Marko Luk\u0161a. It is pretty popular and gives an excellent overview of what is going on under the hood of Kubernetes and how to use it."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},82143:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/control_plane-397b956fed4bf1d337bb8921734969d1.png"},82187:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/deployment_components-3102cf8d2b9f969146abd9838a4fc111.png"},38506:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/gif_k8s_final-35a7e2c22ca4a7577e16499b1fae6181.gif"},64227:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/github_stars-1ca0ec90e9bd7695498845c4cad2c579.gif"},15928:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/k8s_cluster-8acab5a1ab30bdbdd62ff04fe5a4a19c.png"},99944:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/nodes-3cf456eb1b4d1b27a9a1210fd0a4cbdb.png"},19096:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/prestige_gif-8109b97990185c464e119132f5dfaba6.gif"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(96540);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);