"use strict";(self.webpackChunkcyclops_ui_docs=self.webpackChunkcyclops_ui_docs||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/11/13/JSON-schemas","metadata":{"permalink":"/blog/2023/11/13/JSON-schemas","source":"@site/blog/2023-11-13-JSON-schemas/index.md","title":"How Cyclops utilizes JSON schema to deliver dynamical UI","description":"Cyclops turns complicated YAML manifests into simple and structured UIs where developers can click away their Kubernetes application configuration.","date":"2023-11-13T00:00:00.000Z","formattedDate":"November 13, 2023","tags":[],"readingTime":3.735,"hasTruncateMarker":false,"authors":[{"name":"Petar Cvitanovi\u0107","title":"Cyclops CTO","url":"https://github.com/petar-cvit","imageURL":"https://github.com/petar-cvit.png","key":"petarc"}],"frontMatter":{"title":"How Cyclops utilizes JSON schema to deliver dynamical UI","authors":["petarc"]},"unlisted":false,"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"Cyclops turns complicated YAML manifests into simple and structured UIs where developers can click away their Kubernetes application configuration.\\n\u201dGreat! But how does it know how to render this UI? Should I implement a UI form each time I need a new set of fields to configure? I don\u2019t know React! I don\u2019t know frontend!\u201c\\n\\nThis blog post should cure your anxiety about implementing a UI for each type of application and explain how Cyclops knows what to render so you can deploy to your K8s cluster carefree.\\n\\nTo better understand how Cyclops renders the UI, we will scratch the surface of Helm, which Cyclops uses as its templating engine.\\n\\n## A bit about Helm\\n\\nHelm is a Kubernetes package manager that helps deploy and manage Kubernetes resources by packing them into charts. It also has a templating engine that allows developers to configure their apps depending on the specific values injected into the helm template.\\n\\nThe usual Helm chart structure is as follows:\\n\\n```bash\\n\u251c\u2500\u2500 Chart.yaml\\n\u251c\u2500\u2500 templates\\n\u2502   \u251c\u2500\u2500 deployment.yaml\\n\u2502   \u2514\u2500\u2500 service.yaml\\n\u251c\u2500\u2500 values.schema.json\\n\u2514\u2500\u2500 values.yaml\\n```\\n\\n> A few other Helm chart parts are left out on purpose since they are not tangible to the rest of the blog. You can read more about each of those in [Helm\u2019s official documentation](https://helm.sh/docs/topics/charts/)\\n\\n- `Chart.yaml` - A YAML file containing information about the chart (like name, version\u2026)\\n- `templates` - A directory of templates that, when combined with values, will generate valid Kubernetes manifest files.\\n- `values.yaml` - The default configuration values for this chart\\n- `values.schema.json` - A JSON Schema for imposing a structure on the `values.yaml` file\\n\\nWhen using Helm, you can change your `values.yaml` however you see fit for your application. The problem is that you can change them *however* you like, which allows you to misconfigure some parts of your application because you misspelled a field or messed up indentation in the `values.yaml`.\\n\\nHere is where JSON schema from the values.schema.json comes in. It is represented as https://json-schema.org. It will define which fields you should set and even to which values (e.g., you can specify that a field called replicas can\u2019t be set to lower than 0). Helm won\u2019t let you render a Kubernetes manifest with values that don\u2019t comply with the schema. There is an example of such schema later in the blog, but you can also check it out on [Helms official docs](https://helm.sh/docs/topics/charts/#schema-files)\\n\\n## Helm values schema and Cyclops UI\\n\\nNow that we have concluded the schema\'s purpose in a Helm chart, we can understand how Cyclops uses it.\\n\\nSince the primary purpose of the values schema is to describe what the Helm chart needs to render all the Kubernetes resources, we naturally decided to use it for rendering the UI. On the first iterations of Cyclops, we implemented a solution where users can define those fields in the UI, but why reinvent the wheel when Helm already provided a way to specify this?\\n\\nCyclops controller reads the Helm chart and values schema. Then, it recursively traverses through all the fields in the schema and renders the field based on the field specification. It knows how to render a field based on the field type (`string`, `boolean`, `object`, `array`...), description of the field, field rules (e.g., minimum or maximum value), and many more.\\n\\n![Untitled](../../static/img/2023-11-13-JSON-schemas/JSON-to-UI.png)\\n\\nNow that we have a rendered UI, a user of Cyclops can click through the form and fill in those fields. Thanks to the schema, values entered by a developer will now always conform to the schema since the UI won\u2019t let you specify any fields (e.g., allow you typos in field names) or set the number of replicas to `three`. This is an exaggerated example, but you can probably see the point. UI will take care of validating your input, and you will have clear guidelines on how to configure your service.\\n\\nOnce values are entered and saved in the UI, they are passed to the Helm templating engine, along with the templates from the `/templates` folder, resulting in all Kubernetes resources configured for the needs of each team/developer without getting into specific implementation details of each resource.\\n\\n![Untitled](../../static/img/2023-11-13-JSON-schemas/UI-to-K8s.png)\\n\\n## Final thoughts\\n\\nHope this blog post helped you understand how the rendering part of Cyclops works and demystified the whole project. We briefly touched on [Helm](https://helm.sh/docs/) and [JSON schema](https://json-schema.org/), but both are larger pieces of software than we can describe in such a short blog post, so we encourage you to check their documentation."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2023-10-29-welcome/index.md","title":"Welcome","description":"Hi all!","date":"2023-10-29T00:00:00.000Z","formattedDate":"October 29, 2023","tags":[],"readingTime":0.525,"hasTruncateMarker":false,"authors":[{"name":"Petar Cvitanovi\u0107","title":"Cyclops CTO","url":"https://github.com/petar-cvit","imageURL":"https://github.com/petar-cvit.png","key":"petarc"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["petarc"]},"unlisted":false,"prevItem":{"title":"How Cyclops utilizes JSON schema to deliver dynamical UI","permalink":"/blog/2023/11/13/JSON-schemas"}},"content":"Hi all!\\n\\nWe are launching a blog post series on topics relevant to people following our startup journey. From technical topics \\nlike building high availability apps in Kubernetes to nontechnical ones, like our experience in some of the accelerators\\nwe have been through.\\n\\nOverall, we hope you will enjoy the content, and of course, you are more than encouraged to propose some topics you \\nwould like to see here on our Discord.\\n\\nAlso, if you are interested in contributing to our project, you can find open issues on our GitHub repository, and while\\nyou are there, give it a star :star:\\n\\n**Blog posts coming soon...**"}]}')}}]);